---
title: "PSP data cleaning"
author: "A. Clason"
date: "September 16, 2019"
output: html_document
---
Libraries
```{r}
library(data.table)
```

Import data
```{r}
r.path <- "D:/PSP data/PSP csv/"
#write an ifelse function to define machine path?
m.path <- "C:/Users/Alana2012/ALANA_FILES/"
m.path <- "C:/Users/alana_laptop/Documents/"

source(paste0(m.path,"GitHub/SORTIE-r/SORTIE-functions.R"))
dat.type <- c("Sample","Trees")
tsas <- c("03","12","14","20","24","26")
tsas <- c("03","04","05","07","08","09","10","11","12","13","14","15","16","17","18","20","22","23","24","25","26","27","29","30","31","38","39","40","41","43","44","45","46","47","48")
#("url = https://drive.google.com/drive/u/0/folders/1DgeDUB4l62P9uWXwE8OLEE720_aHa5xT")
psp.dat <- import.psp(r.path = r.path, dat.type=dat.type, tsas=tsas)
#result is psp.dat which contains [[1]]:Sample and [[2]]Trees
unique(psp.dat[[1]]$tsa)

```

SITE SERIES APPROACH:

Sample data

This step will involve understanding all the information on a plot that is available, and determining which plots will be useful for a given purpose. Once the plots are id'd then can select those plotIDs from the Trees dataset (element 2 in psp.dat)
Minimum Criteria:
1. Is the plot in the SBSmc2?
2. Does it have a Site Series call?

```{r}
#take the sample data.table out of a list and save in data.table format
samples.dt <- psp.dat[[1]]
# Remove repeats (which I think represent sub-plots)
uni.samples.dt<-unique(samples.dt, by="SAMP_ID")

#create the list of criteria needed to determine whether a plot should be included. This assumes that coding is consistent i.e SBSmc2 is spelled the same across datasets.
criteria.samples <- uni.samples.dt[beclabel_grd=="SBSmc2" & bgc_ss_grd>0]
#The bgc_zone call is not accurate and the beclabel_grd (ground call should be used when possible)
criteria.samples <- uni.samples.dt[bgc_zone=="SBS"& bgc_ss_grd>0]
table(criteria.samples$bgc_ss_grd)
table(criteria.samples$beclabel)
#All SBPS, SBS
criteria.samples <- uni.samples.dt[beclabel_grd=="SBPS"|beclabel_grd=="SBPSdc"|beclabel_grd=="SBPSmc" |beclabel_grd== "SBPSmk" |beclabel_grd== "SBPSmk1" |beclabel_grd== "SBPSmk3" |beclabel_grd== "SBPSxc" |beclabel_grd=="SBPSxc1" |beclabel_grd== "SBPSxc3" |beclabel_grd== "SBPSxc4" |beclabel_grd== "SBS" |beclabel_grd== "SBS1" |beclabel_grd== "SBS2"|beclabel_grd== "SBS3" |beclabel_grd== "SBSdh1" |beclabel_grd== "SBSdh2" |beclabel_grd== "SBSdk" |beclabel_grd== "SBSdk1" |beclabel_grd== "SBSdk2" |beclabel_grd== "SBSdw" |beclabel_grd== "SBSdw1" |beclabel_grd== "SBSdw2" |beclabel_grd== "SBSdw3" |beclabel_grd== "SBSmc"|beclabel_grd== "SBSmc1" |beclabel_grd== "SBSmc2" |beclabel_grd== "SBSmc3" |beclabel_grd== "SBSmh" |beclabel_grd== "SBSmk" |beclabel_grd== "SBSmk1" |beclabel_grd== "SBSmk2" |beclabel_grd== "SBSmm" |beclabel_grd== "SBSmw"|beclabel_grd== "SBSun" |beclabel_grd== "SBSvk" |beclabel_grd== "SBSvk1" |beclabel_grd== "SBSwk" |beclabel_grd== "SBSwk1" |beclabel_grd== "SBSwk2" |beclabel_grd== "SBSwk3" & bgc_ss_grd>0]

table(criteria.samples$bgc_zone)
table(criteria.samples$beclabel_grd)
table(criteria.samples$bgc_ss_grd)

criteria.samples <- uni.samples.dt[beclabel_grd== "SBS" |beclabel_grd== "SBS1" |beclabel_grd== "SBS2"|beclabel_grd== "SBS3" |beclabel_grd== "SBSdh1" |beclabel_grd== "SBSdh2" |beclabel_grd== "SBSdk" |beclabel_grd== "SBSdk1" |beclabel_grd== "SBSdk2" |beclabel_grd== "SBSdw" |beclabel_grd== "SBSdw1" |beclabel_grd== "SBSdw2" |beclabel_grd== "SBSdw3" |beclabel_grd== "SBSmc"|beclabel_grd== "SBSmc1" |beclabel_grd== "SBSmc2" |beclabel_grd== "SBSmc3" |beclabel_grd== "SBSmh" |beclabel_grd== "SBSmk" |beclabel_grd== "SBSmk1" |beclabel_grd== "SBSmk2" |beclabel_grd== "SBSmm" |beclabel_grd== "SBSmw"|beclabel_grd== "SBSun" |beclabel_grd== "SBSvk" |beclabel_grd== "SBSvk1" |beclabel_grd== "SBSwk" |beclabel_grd== "SBSwk1" |beclabel_grd== "SBSwk2" |beclabel_grd== "SBSwk3" & bgc_ss_grd>0]

table(criteria.samples$bgc_zone)
table(criteria.samples$bgc_ss_grd)

#ifelse(criteria.samples[,beclabel_grd]=="SBSmc2",criteria.samples[,aBGC_SS:=],)

```


```{r}
aSMR_in <- fread("C:/Users/alana_laptop/Documents/Sync/BVRC/SORTIE position/Data/aSMR/aSMR_letters.csv", h=T)


```



Re-measurement criteria:

1. What plots have multiple measurements?
2. What is the greatest time span for these measurements?
```{r}
remeas.samples <- criteria.samples[(criteria.samples[,meas_yr_first]!=criteria.samples[,meas_yr_last])]
range(remeas.samples[,tot_period]) #indicates minimum gap in re-measurements
table(remeas.samples$bgc_ss_grd)
remeas.samples <- remeas.samples[tot_period>=10]
table(remeas.samples$bgc_ss_grd)

#this is all the SBS plots with 02 call
plot.SORTIE <- unique(remeas.samples[bgc_ss_grd==6]$SAMP_ID)
#plot.SORTIE <- plot.SORTIE[plot.SORTIE!="CMI5_0232_NFI"]
#tree species
tree.dat <- psp.dat[[2]]
tree.dat.plot.SORTIE <- tree.dat[samp_id %in% plot.SORTIE]

# Fix species names - need to make a more generic function (borrow from LandR)?
unique(tree.dat.plot.SORTIE$species)

#S might not be Spruce? Might be scouler's willow...seems unlikely, all the other willows are Wsomething. Tons of sites have "S" - more likely spruce
tree.dat.plot.SORTIE[,sp_PSP:=ifelse(species=="SW","SX",
                         ifelse(species=="S","SX",
                                ifelse(species=="B","BL",
                                       ifelse(species =="DM","D",
                                              ifelse(species=="DR","D",
                                                     ifelse(species=="AC","AT",
                                                            species))))))]



unique(tree.dat.plot.SORTIE$sp_PSP)
setkey(tree.dat.plot.SORTIE)
#remove plots based on composition: actually just need to remove from plotID
rm.plot <- unique(tree.dat.plot.SORTIE[which(tree.dat.plot.SORTIE[,species==.("XC","CW")]),.(samp_id)])
tree.dat.plot.SORTIE.rm.sp <- tree.dat.plot.SORTIE[!rm.plot]

#remove if treated (thinned or planted)
samp.reduced <- remeas.samples[SAMP_ID %in% unique(tree.dat.plot.SORTIE.rm.sp$samp_id)]
analysis.samples <- unique(samp.reduced[treatment != "THINNED" & stnd_org!="P"]$SAMP_ID)

#back to CreateParamsCSV...


#how many trees of each species by plot
tree.per.plot <- tree.dat.plot.SORTIE[,.N, by=.(samp_id,species)]
```
There could be one analysis here that tries to grow specific plot situations: thinned, beetle-killed etc. But for now, proceed to find the most number of plots that conform

Analysis criteria:

1. Remove if thinned
2. Remove if the plot planted (only 2 and they were also thinned)
```{r}
analysis.samples <- remeas.samples[treatment != "THINNED" & stnd_org!="P"] #72? plots if use site series calls
table(analysis.samples$bgc_ss_grd)
#it seems that there is only 1 plot for all plots I've cut down to if I use all plots and don't remove duplicates:
#all.samps.dt <- samples.dt[beclabel=="SBSmc2" & bgc_ss_grd>0 & meas_yr_first != meas_yr_last & treatment != "THINNED"] 
all.samps.dt <- analysis.samples
all.samps.dt[,area_pm == area_ps]
range(all.samps.dt[, no_plots])
unique(all.samps.dt[, shp_pm]) #all circles
all.samps.dt[SAMP_ID=="CMI5_0232_NFI",area_pm] #just saw different calls on Site Series for this plot - 01 in 2001, 02 in 2017

all.samps.dt[which(all.samps.dt[,bgc_ss_grd==2]),.(SAMP_ID,tsa,beclabel)]

analysis.samples[,no_plots]
analysis.samples[,area_ps]

samples.dt[SAMP_ID=="CMI5_0232_NFI",1:100]

analysis.samples[,area_pm]
remeas.samples[,no_plots]
remeas.samples[,no_meas]

remeas.samples[,dbhlimit_breakpt] #tag limit in main vs. subplots
remeas.samples[,dbhlimit_tag] #tag limit in sub-plots
remeas.samples[which(remeas.samples[,bgc_ss_grd==2]),SAMP_ID]
```


SITE INDEX APPROACH:

Doing the same steps, but figuring out how many more or different plots meet the criteria if we include SI
```{r}
#looking at site index range from the plots that meet my criteria other then having site series:
samples.dt <- (psp.dat[[1]])
uni.samples.dt<-unique(samples.dt, by="SAMP_ID")
criteria.samples <- uni.samples.dt[beclabel=="SBSmc2"]
remeas.samples <- criteria.samples[(criteria.samples[,meas_yr_first]!=criteria.samples[,meas_yr_last])]
range(remeas.samples[,tot_period]) #indicates min. remeasurement is 5 years
remeas.samples <- remeas.samples[tot_period>=10] #now has to be 10 years minimum
analysis.samples <- remeas.samples[treatment != "THINNED" & stnd_org!="P" & spc_live1!=""]
analysis.samples[,spc_live1] #104 potential plots if use SI

#look at possible 02 sites:
pine.lead <- analysis.samples[spc_live1=="PL"] #65 stands pine leading
pine.lead[,.(lead_si1,lead_si3,lead_si4,bh_stand_age)]
pine.lead[,lead_si1 := ifelse(lead_si1==-99,NA,lead_si1)]
pine.lead[,bgc_ss_grd := ifelse(is.na(bgc_ss_grd),11,bgc_ss_grd)]
pine.lead[,.(SAMP_ID,tsa,bgc_ss_grd,lead_si1,lead_si3,lead_si4,bh_stand_age)]#[order(lead_si1)]

# So lead_si4 comes from a TEM/PEM/SIBEC map layer. It's tempting to maintain this as an option on the hierarchy of data quality. Seems like it's too coarse to pick out the least productive sites (02?)

#what if I look at all plots and not just pine leading?
analysis.samples[,.(SAMP_ID,tsa,bgc_ss_grd,spc_live1,lead_si1,lead_si3,lead_si4,lead_age_bh1)][order(lead_si1)]

#what if I used an ordination to classify plots based on leading species, SI, Age, Density, etc.
#So far, I can't see any grouping using ordinations, but could use a classification tree (random forest approach)
library(vegan)
library(ecodist)
pca.pine.lead <- princomp(na.omit(pine.lead[,.(lead_si1,lead_si3,lead_si4,bh_stand_age,stemsha_LIV)]))
biplot(pca.pine.lead)

dist.pine.lead <- bcdist(na.omit(pine.lead[,.(lead_si1,lead_si3,lead_si4,bh_stand_age,stemsha_LIV,aspect, slope)]))
nmds_out <- nmds(dist.pine.lead, mindim=2, maxdim=2)
scores <- nmds.min(nmds_out)
sort(pine.lead[,bgc_ss_grd])
mycol=c("green","yellow","red","blue","purple","orange","brown","black","pink","")
plot(scores, pch=19, col=mycol[pine.lead[,bgc_ss_grd]])


dat <- na.omit(pine.lead[,.(bgc_ss_grd,lead_si1,lead_si3,lead_si4,bh_stand_age,stemsha_LIV,aspect, slope)])
dat1 <- dat[,.(lead_si1,lead_si3,lead_si4,bh_stand_age,stemsha_LIV,aspect, slope)]
dist.pine.lead <- bcdist(dat1)
out1 <- metaMDS(dist.pine.lead, k=2, trymax=500)
plot(out1$points, pch=19)
mycol = c("green","red","blue","purple","black")
plot(out1$points, pch=19, col=mycol[sort(unique(dat[,bgc_ss_grd]))])
vectors <- vf(out1$points, dat ,nperm=10)
plot(vectors, col="red")
mygroups <- sort(unique(dat[,bgc_ss_grd]))
for (i in 1:6){
 ordiellipse(out1$points, dat[,bgc_ss_grd], conf=0.6, col=mycol[i], show.groups=mygroups[i])
}

boxplot(dat$stemsha_LIV~dat$bgc_ss_grd)
boxplot(dat$lead_si1~dat$bgc_ss_grd)

#density doesn't seem to relate to age, SI, or SS for pine leading
plot(dat$stemsha_LIV~dat$lead_si1, pch=19)
plot(dat$stemsha_LIV~dat$bh_stand_age, pch=19)
plot(dat$stemsha_LIV~dat$bgc_ss_grd, pch=19)

analysis.samples[,lead_si1 := ifelse(lead_si1==-99,NA,lead_si1)]
analysis.samples[,bgc_ss_grd := ifelse(is.na(bgc_ss_grd),0,bgc_ss_grd)]
analysis.samples[,.(SAMP_ID,tsa,spc_live1,bgc_ss_grd,lead_si1,lead_si3,lead_si4,bh_stand_age,stemsha_LIV,aspect, slope)]#[order(lead_si1)]

plot(analysis.samples$stemsha_LIV~analysis.samples$lead_si1, pch=19)
plot(analysis.samples$stemsha_LIV~analysis.samples$bh_stand_age, pch=19)
plot(analysis.samples$stemsha_LIV~analysis.samples$bgc_ss_grd, pch=19)

```


#this is getting ahead of myself - looking at diameters in 02 plot. But what I was looking for is what trees count in these plots. Not looking like regen would be tallied? Unless X = ingrowth

2. how large is the plot # paf is the factor you multiply to get 1 ha. 1ha/paf = plot size (1/250=0.04)
3. How old is the plot?
4. What size classes of trees were measured?
5. Is it a fixed area or variable area plot?
6. MPB?

Create the Tree Population Parameters for a SORTIE run: 
This is all hard coded in the sense that if I changed the order of species, this will break.
```{r}

#size classes = upper limit DBH, 0 = seedlings <2cm DBH. I'm going to switch it so that it starts at 4cm to go with PSP data?
New.Seedling.Diam.10cm <- 1
Sdlg.Hgt.Class.1.Upp.B <- 1
Sdlg.Hgt.Class.2.Upp.B <-1
#Tree.Map.To.Add.As.Text <- 1
SORTIE.species <- c("Interior_Spruce","Lodgepole_Pine","Subalpine_Fir","Trembling_Aspen")
Min.Adult.DBH <- c(3.0,5.0,5.0,5.0)
Max.Seedling.Hgt.m <- rep(1.35, length(SORTIE.species))
Init.Dens.Seedling.Hgt.Class.1 <- rep(0, length(SORTIE.species))
Init.Dens.Seedling.Hgt.Class.2 <- rep(0, length(SORTIE.species))
Init.Dens.Seedling.Hgt.Class.3 <- rep(0, length(SORTIE.species))
Init.Dens.Seedling <- rep(0, length(SORTIE.species))
sizeClasses <- seq(4,80, by =2)
inits <- vector()
  init.values <- matrix(nrow=length(sizeClasses),ncol=length(SORTIE.species))
  for(i in 1:length(sizeClasses)){
    inits[i] <- paste0("Init.Dens.",sizeClasses[i])
  }
  row.names(init.values) <- inits
  for(j in 1:length(SORTIE.species)){
    init.values[,j] <- rep(0, length(inits))
  }

# Now create the data.table of parameter values that vary
SORTIE.tree.dat <- data.table()
SORTIE.tree.dat <- rbind(Min.Adult.DBH,Max.Seedling.Hgt.m,Init.Dens.Seedling.Hgt.Class.1,Init.Dens.Seedling.Hgt.Class.2,Init.Dens.Seedling.Hgt.Class.3,Init.Dens.Seedling,init.values)
colnames(SORTIE.tree.dat)<-SORTIE.species

# Figure out which tree values to change (all in #/ha):
#I'm using L, I, V as alive, DU and DP as dead. Live Dead tree flag : L=live, I=Live ingrowth exceeding minimum DBH tagging limit (if a subplot tree) or exceeding breakpoint DBH limit (if in main plot), V=live vet, DP=dead potential (<50% decay), DU=dead useless (>=50% decay), C=cut, X=ingrowth less than minimum DBH of 4.0cm

tree.dat <- psp.dat[[2]]
plot.SORTIE <- "60136 G000004"
#convert to species id
#I need to decide when to clean the species data, but because I'm just making some runs for a plot that I know, I'm going to change SW to SX here for now
#unique(tree.dat[,species])
tree.dat[,sp_PSP:=ifelse(species=="SW","SX",species)]

PSP.species <- c("SX","PL","BL","AT")
SORTIE.species <- c("Interior_Spruce","Lodgepole_Pine","Subalpine_Fir","Trembling_Aspen")
tree.conv.table <- data.table(cbind(PSP.species,SORTIE.species))
num.meas <- length(unique(tree.dat[samp_id==plot.SORTIE,meas_no]))

#This assumes the min phf is the main plot
SORTIE.tree.psp.dat <- list()
Plot.ReMeas.MainPlot.list <- list()
for(i in 1:num.meas){
  plot.SORTIE.meas <- tree.dat[samp_id==plot.SORTIE & meas_no==(i-1)]
  plot.SORTIE.meas[,LD_Group:=ifelse(ld=="L",1,ifelse(ld=="I",1,ifelse(ld=="V",1,2)))]
  red.plot.SORTIE.meas <- plot.SORTIE.meas[,.(samp_id,meas_yr,phf_tree,sp_PSP,dbh,ld,LD_Group,age_bh,height)]
  #just live species
  main.plot.phf <- min(red.plot.SORTIE.meas[,phf_tree])
  ld.red.plot.SORTIE.meas <- red.plot.SORTIE.meas[LD_Group==1 & phf_tree==main.plot.phf]
  for(j in 1:length(sizeClasses)){
      ld.red.plot.SORTIE.meas[dbh <= sizeClasses[j] & dbh > sizeClasses[j]-2,DBH_bin := j]
  }
Plot.ReMeas.list[[i]] <- red.plot.SORTIE.meas[phf_tree==main.plot.phf]
tree.per.bin <- ld.red.plot.SORTIE.meas[,.N, by=.(DBH_bin,sp_PSP)]
tree.per.bin[,Trees.per.ha := N*main.plot.phf]
setkey(tree.per.bin,sp_PSP,DBH_bin)

  SORTIE.tree.psp.dat[[i]] <- SORTIE.tree.dat
  for(k in 1:nrow(tree.per.bin)){
  SORTIE.tree.psp.dat[[i]][6+tree.per.bin[k,DBH_bin],tree.conv.table[PSP.species==tree.per.bin[k,sp_PSP],SORTIE.species]] <- tree.per.bin[k,Trees.per.ha]
  }
}



```


Selecting 2 of the best '02' plots
```{r}
samples.dt <- (psp.dat[[1]])
#only one row per sample ID
uni.samples.dt<-unique(samples.dt, by="SAMP_ID")
criteria.samples <- uni.samples.dt[beclabel=="SBSmc2" & bgc_ss_grd>0]
table(criteria.samples$bgc_ss_grd)
remeas.samples <- criteria.samples[(criteria.samples[,meas_yr_first]!=criteria.samples[,meas_yr_last])]
table(remeas.samples$bgc_ss_grd)
analysis.samples <- remeas.samples[treatment != "THINNED" & stnd_org!="P"] #72? plots if use site series calls
analysis.samples[which(analysis.samples[,bgc_ss_grd==2]),.(SAMP_ID,tsa)]


#all rows
all.samps.dt <- samples.dt[beclabel=="SBSmc2" & bgc_ss_grd>0 & meas_yr_first != meas_yr_last & treatment != "THINNED"] 
all.samps.dt[,area_pm == area_ps]
all.samps.dt[which(all.samps.dt[,bgc_ss_grd==2]),.(SAMP_ID,tsa)]

#I need a 9 ha plot generated from the diameter distribution

psp.dat[[2]][,samp_plotID := paste0(samp_id,"_",plot_no)]

```

